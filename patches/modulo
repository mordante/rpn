Bottom: 58c291715cf918ed6353bfba91097bb4759024dc
Top:    08802a1478113534f2300e9ec79e7fa9dbd7a9fd
Author: Mark de Wever <koraq@xs4all.nl>
Date:   2023-02-06 17:36:48 +0100

Modulo


---
diff --git a/doc/calculation.rst b/doc/calculation.rst
index 5042da4..20fa61d 100644
--- a/doc/calculation.rst
+++ b/doc/calculation.rst
@@ -236,6 +236,34 @@ Negate
 * Returns: :ref:`store_prefer_uint64_t<to-storage-uint64_t>`.
 
 
+Modulo
+------
+
+* If either ``lhs`` or ``rhs`` is a double:
+
+  * ``lhs`` is :ref:`double converted<conversion-double>`.
+  * ``rhs`` is :ref:`double converted<conversion-double>`.
+  * Returns: a ``double``.
+
+* Else if both ``lhs`` and ``rhs`` are an ``int64_t``:
+
+  * ``lhs`` is :ref:`unmodified<conversion-unmodified>`.
+  * ``rhs`` is :ref:`unmodified<conversion-unmodified>`.
+  * Returns: :ref:`store_prefer_uint64_t<to-storage-int64_t>`.
+
+* Else if both ``lhs`` and ``rhs`` are an ``unt64_t``:
+
+  * ``lhs`` is :ref:`unmodified<conversion-unmodified>`.
+  * ``rhs`` is :ref:`unmodified<conversion-unmodified>`.
+  * Returns: :ref:`store_prefer_uint64_t<to-storage-int64_t>`.
+
+* Else:
+
+  * ``lhs`` is :ref:`unmodified<conversion-unmodified>`.
+  * ``rhs`` is :ref:`unmodified<conversion-unmodified>`.
+  * Returns: :ref:`store_prefer_uint64_t<to-storage-uint64_t>`.
+
+
 Bitwise logical operations
 ==========================
 
diff --git a/doc/changelog.rst b/doc/changelog.rst
index f20f5d1..7acefe2 100644
--- a/doc/changelog.rst
+++ b/doc/changelog.rst
@@ -26,6 +26,7 @@ Focusses on improving the input parsing and adding more operations.
   * Using of grouping in the display's output.
   * pow.
   * Miscellaneous: debug mode.
+  * Arithmetic: modulo
 
 * Added a terminal based interface.
 
diff --git a/src/modules/calculator/controller.cpp b/src/modules/calculator/controller.cpp
index 6ea06e3..a9e5537 100644
--- a/src/modules/calculator/controller.cpp
+++ b/src/modules/calculator/controller.cpp
@@ -214,6 +214,9 @@ void tcontroller::handle_keyboard_input_no_modifiers(char key) {
   case '/':
     return math_binary_operation(&math::div);
 
+  case '%':
+    return math_binary_operation(&math::mod);
+
     /*** Bitwise operations ***/
   case '&':
     return math_binary_operation(&math::bit_and);
diff --git a/src/modules/calculator/math/arithmetic.cpp b/src/modules/calculator/math/arithmetic.cpp
index 23876b6..87b9f95 100644
--- a/src/modules/calculator/math/arithmetic.cpp
+++ b/src/modules/calculator/math/arithmetic.cpp
@@ -189,6 +189,57 @@ export tstorage negate(tstorage value) {
   return negate(get<double>(value));
 }
 
+/** @see https://mordante.github.io/rpn/calculation.html#modulo */
+static int64_t mod(int64_t lhs, int64_t rhs) {
+  if (rhs == 0)
+    throw std::domain_error("Division by zero");
+  return lhs % rhs;
+}
+
+static uint64_t mod(uint64_t lhs, uint64_t rhs) {
+  if (rhs == 0)
+    throw std::domain_error("Division by zero");
+  return lhs % rhs;
+}
+
+static tstorage mod(__int128_t lhs, __int128_t rhs) {
+  if (rhs == 0)
+    throw std::domain_error("Division by zero");
+  return to_storage(lhs % rhs);
+}
+
+static double mod(double lhs, double rhs) {
+  if (rhs == 0.)
+    throw std::domain_error("Division by zero");
+  return std::fmod(lhs, rhs);
+}
+
+export tstorage mod(const tstorage &lhs, const tstorage &rhs) {
+  if (std::holds_alternative<double>(lhs) ||
+      std::holds_alternative<double>(rhs))
+    return mod(double_cast(lhs), double_cast(rhs));
+
+  if (std::holds_alternative<int64_t>(lhs) &&
+      std::holds_alternative<int64_t>(rhs))
+    return mod(get<int64_t>(lhs), get<int64_t>(rhs));
+
+  if (std::holds_alternative<uint64_t>(lhs) &&
+      std::holds_alternative<uint64_t>(rhs))
+    return mod(get<uint64_t>(lhs), get<uint64_t>(rhs));
+
+  // At this point either lhs or rhs is an uint64_t and the other is an
+  // int64_t. Since the calculation needs to be done in 128-bit domain
+  // do a cast here. (With some additional sanity checks most can be done in
+  // 64-bit. TODO improve this function.)
+
+  if (std::holds_alternative<uint64_t>(lhs))
+    return mod(static_cast<__int128_t>(get<uint64_t>(lhs)),
+               static_cast<__int128_t>(get<int64_t>(rhs)));
+
+  return mod(static_cast<__int128_t>(get<int64_t>(lhs)),
+             static_cast<__int128_t>(get<uint64_t>(rhs)));
+}
+
 // TODO static can't be used, since caller is a template.
 /*static*/ tstorage pow(double value, int exp) { return std::pow(value, exp); }
 
diff --git a/tests/CMakeLists.txt b/tests/CMakeLists.txt
index cc67474..456d4cd 100644
--- a/tests/CMakeLists.txt
+++ b/tests/CMakeLists.txt
@@ -14,6 +14,7 @@ add_executable(tests
 	calculator/controller/key_char_greater_than.cpp
 	calculator/controller/key_char_less_than.cpp
 	calculator/controller/key_char_minus.cpp
+	calculator/controller/key_char_percentage.cpp
 	calculator/controller/key_char_pipe.cpp
 	calculator/controller/key_char_plus.cpp
 	calculator/controller/key_char_star.cpp
@@ -34,6 +35,7 @@ add_executable(tests
 	calculator/value.cpp
 	calculator/value/math/arithmetic/add.cpp
 	calculator/value/math/arithmetic/division.cpp
+	calculator/value/math/arithmetic/modulo.cpp
 	calculator/value/math/arithmetic/multiply.cpp
 	calculator/value/math/arithmetic/negate.cpp
 	calculator/value/math/arithmetic/power.cpp
diff --git a/tests/calculator/controller/key_char_default.cpp b/tests/calculator/controller/key_char_default.cpp
index ad41c7c..f20dd19 100644
--- a/tests/calculator/controller/key_char_default.cpp
+++ b/tests/calculator/controller/key_char_default.cpp
@@ -25,7 +25,7 @@ constexpr std::string_view all_characters =
     "0123456789"
     "`-=~!@#$%^&*()_+[]\\{}|;':\",./<>?";
 
-constexpr std::string_view special_characters_no_modifier = "+-/*&|^~<>";
+constexpr std::string_view special_characters_no_modifier = "+-/%*&|^~<>";
 constexpr std::string_view special_characters_control = "bodhnzZ23456789";
 
 namespace calculator {
diff --git a/tests/calculator/controller/key_char_percentage.cpp b/tests/calculator/controller/key_char_percentage.cpp
new file mode 100644
index 0000000..3d3f2b4
--- /dev/null
+++ b/tests/calculator/controller/key_char_percentage.cpp
@@ -0,0 +1,105 @@
+/*
+ * Copyright (C) Mark de Wever <koraq@xs4all.nl>
+ * Part of the RPN project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY.
+ *
+ * See the COPYING file for more details.
+ */
+
+import calculator.controller;
+
+import calculator.model;
+import tests.format_error;
+import tests.handle_input;
+
+#include <gtest/gtest.h>
+
+namespace calculator {
+
+TEST(controller, key_char_percentage_too_few_elements) {
+  tmodel model;
+  tcontroller controller{model};
+
+  controller.handle_keyboard_input(tmodifiers::none, '%');
+  EXPECT_EQ(model.diagnostics_get(),
+            format_error("The stack doesn't contain two elements"));
+  EXPECT_TRUE(model.stack().empty());
+  EXPECT_TRUE(model.input_get().empty());
+
+  handle_input(controller, model, "42");
+  controller.handle_keyboard_input(tmodifiers::none, '%');
+  EXPECT_EQ(model.diagnostics_get(),
+            format_error("The stack doesn't contain two elements"));
+  EXPECT_EQ(model.stack().strings(), std::vector<std::string>{"42"});
+  EXPECT_TRUE(model.input_get().empty());
+}
+
+TEST(controller, key_char_percentage_stack_input) {
+  tmodel model;
+  tcontroller controller{model};
+  handle_input(controller, model, "42");
+  model.input_append("42");
+
+  controller.handle_keyboard_input(tmodifiers::none, '%');
+  EXPECT_TRUE(model.diagnostics_get().empty());
+  EXPECT_EQ(model.stack().strings(), std::vector<std::string>{"0"});
+  EXPECT_TRUE(model.input_get().empty());
+}
+
+TEST(controller, key_char_percentage_stack_stack) {
+  tmodel model;
+  tcontroller controller{model};
+  handle_input(controller, model, "42");
+  handle_input(controller, model, "42");
+
+  controller.handle_keyboard_input(tmodifiers::none, '%');
+  EXPECT_TRUE(model.diagnostics_get().empty());
+  EXPECT_EQ(model.stack().strings(), std::vector<std::string>{"0"});
+  EXPECT_TRUE(model.input_get().empty());
+}
+
+TEST(controller, key_char_percentage_diagnostics_cleared) {
+  tmodel model;
+  tcontroller controller{model};
+  model.diagnostics_set("Cleared");
+  handle_input(controller, model, "42");
+  handle_input(controller, model, "42");
+
+  controller.handle_keyboard_input(tmodifiers::none, '%');
+  EXPECT_TRUE(model.diagnostics_get().empty());
+  EXPECT_EQ(model.stack().strings(), std::vector<std::string>{"0"});
+  EXPECT_TRUE(model.input_get().empty());
+}
+
+TEST(controller, key_char_percentage_input_invalid) {
+  tmodel model;
+  tcontroller controller{model};
+  handle_input(controller, model, "42");
+  model.input_append("abc");
+
+  controller.handle_keyboard_input(tmodifiers::none, '%');
+  EXPECT_EQ(model.diagnostics_get(),
+            format_error("Invalid numeric value or command"));
+  EXPECT_EQ(model.stack().strings(), std::vector<std::string>{"42"});
+  EXPECT_EQ(model.input_get(), "abc");
+}
+
+TEST(controller, key_char_backslash_division_zero) {
+  tmodel model;
+  tcontroller controller{model};
+  handle_input(controller, model, "42");
+  model.input_append("0");
+
+  controller.handle_keyboard_input(tmodifiers::none, '%');
+  EXPECT_EQ(model.diagnostics_get(), format_error("Division by zero"));
+  EXPECT_EQ(model.stack().strings(), std::vector<std::string>{"42"});
+  EXPECT_EQ(model.input_get(), "0");
+}
+
+} // namespace calculator
diff --git a/tests/calculator/value/math/arithmetic/modulo.cpp b/tests/calculator/value/math/arithmetic/modulo.cpp
new file mode 100644
index 0000000..597780f
--- /dev/null
+++ b/tests/calculator/value/math/arithmetic/modulo.cpp
@@ -0,0 +1,194 @@
+/*
+ * Copyright (C) Mark de Wever <koraq@xs4all.nl>
+ * Part of the RPN project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY.
+ *
+ * See the COPYING file for more details.
+ */
+
+import calculator.math.arithmetic;
+
+import <cmath>;
+import <limits>;
+
+#include <gtest/gtest.h>
+
+namespace calculator {
+namespace math {
+
+TEST(arithmetic, mod_int64_t_int64_t) {
+  ASSERT_TRUE(std::holds_alternative<int64_t>(
+      mod(tstorage{int64_t(1)}, tstorage{int64_t(1)})));
+
+  EXPECT_EQ(std::get<int64_t>(mod(tstorage{int64_t(4)}, tstorage{int64_t(3)})),
+            1);
+  EXPECT_EQ(std::get<int64_t>(mod(tstorage{int64_t(4)}, tstorage{int64_t(-3)})),
+            1);
+  EXPECT_EQ(std::get<int64_t>(mod(tstorage{int64_t(-1)}, tstorage{int64_t(3)})),
+            -1);
+  EXPECT_EQ(
+      std::get<int64_t>(mod(tstorage{int64_t(-4)}, tstorage{int64_t(-3)})), -1);
+
+  EXPECT_THROW(mod(tstorage{int64_t(3)}, tstorage{int64_t(0)}),
+               std::domain_error);
+}
+
+TEST(arithmetic, mod_int64_t_uint64_t) {
+  ASSERT_TRUE(std::holds_alternative<uint64_t>(
+      mod(tstorage{int64_t(4)}, tstorage{uint64_t(3)})));
+
+  EXPECT_EQ(
+      std::get<uint64_t>(mod(tstorage{int64_t(4)}, tstorage{uint64_t(3)})), 1);
+
+  ASSERT_TRUE(std::holds_alternative<int64_t>(
+      mod(tstorage{int64_t(-4)}, tstorage{uint64_t(3)})));
+  EXPECT_EQ(
+      std::get<int64_t>(mod(tstorage{int64_t(-4)}, tstorage{uint64_t(3)})), -1);
+
+  EXPECT_THROW(mod(tstorage{int64_t(3)}, tstorage{uint64_t(0)}),
+               std::domain_error);
+}
+
+TEST(arithmetic, mod_int64_t_double) {
+  ASSERT_TRUE(std::holds_alternative<double>(
+      mod(tstorage{int64_t(1)}, tstorage{double(1)})));
+
+  EXPECT_EQ(std::get<double>(mod(tstorage{int64_t(4)}, tstorage{double(1.5)})),
+            1.);
+  EXPECT_EQ(std::get<double>(mod(tstorage{int64_t(4)}, tstorage{double(-1.5)})),
+            1.);
+  EXPECT_EQ(std::get<double>(mod(tstorage{int64_t(-4)}, tstorage{double(1.5)})),
+            -1.);
+  EXPECT_EQ(
+      std::get<double>(mod(tstorage{int64_t(-4)}, tstorage{double(-1.5)})),
+      -1.);
+
+  using limit = std::numeric_limits<double>;
+  EXPECT_TRUE(isnan(std::get<double>(
+      mod(tstorage{int64_t(1)}, tstorage{limit::quiet_NaN()}))));
+  EXPECT_TRUE(isnan(std::get<double>(
+      mod(tstorage{int64_t(1)}, tstorage{limit::signaling_NaN()}))));
+
+  EXPECT_THROW(mod(tstorage{int64_t(3)}, tstorage{double(0)}),
+               std::domain_error);
+}
+
+TEST(arithmetic, mod_uint64_t_int64_t) {
+  ASSERT_TRUE(std::holds_alternative<uint64_t>(
+      mod(tstorage{uint64_t(1)}, tstorage{int64_t(1)})));
+
+  EXPECT_EQ(
+      std::get<uint64_t>(mod(tstorage{uint64_t(4)}, tstorage{int64_t(3)})), 1);
+
+  ASSERT_TRUE(std::holds_alternative<uint64_t>(
+      mod(tstorage{uint64_t(4)}, tstorage{int64_t(-3)})));
+
+  EXPECT_EQ(
+      std::get<uint64_t>(mod(tstorage{uint64_t(4)}, tstorage{int64_t(-3)})), 1);
+
+  EXPECT_THROW(mod(tstorage{uint64_t(3)}, tstorage{int64_t(0)}),
+               std::domain_error);
+}
+
+TEST(arithmetic, mod_uint64_t_uint64_t) {
+  ASSERT_TRUE(std::holds_alternative<uint64_t>(
+      mod(tstorage{uint64_t(4)}, tstorage{uint64_t(3)})));
+
+  EXPECT_EQ(
+      std::get<uint64_t>(mod(tstorage{uint64_t(4)}, tstorage{uint64_t(3)})), 1);
+
+  EXPECT_THROW(mod(tstorage{uint64_t(3)}, tstorage{uint64_t(0)}),
+               std::domain_error);
+}
+
+TEST(arithmetic, mod_double_int64_t) {
+  ASSERT_TRUE(std::holds_alternative<double>(
+      mod(tstorage{double(1)}, tstorage{int64_t(1)})));
+
+  EXPECT_EQ(std::get<double>(mod(tstorage{double(4.5)}, tstorage{int64_t(3)})),
+            1.5);
+  EXPECT_EQ(std::get<double>(mod(tstorage{double(4.5)}, tstorage{int64_t(-3)})),
+            1.5);
+  EXPECT_EQ(std::get<double>(mod(tstorage{double(-4.5)}, tstorage{int64_t(3)})),
+            -1.5);
+  EXPECT_EQ(
+      std::get<double>(mod(tstorage{double(-4.5)}, tstorage{int64_t(-3)})),
+      -1.5);
+
+  using limit = std::numeric_limits<double>;
+  EXPECT_TRUE(isnan(std::get<double>(
+      mod(tstorage{-limit::infinity()}, tstorage{int64_t(1)}))));
+  EXPECT_TRUE(isnan(std::get<double>(
+      mod(tstorage{limit::infinity()}, tstorage{int64_t(1)}))));
+  EXPECT_TRUE(isnan(std::get<double>(
+      mod(tstorage{limit::quiet_NaN()}, tstorage{int64_t(1)}))));
+  EXPECT_TRUE(isnan(std::get<double>(
+      mod(tstorage{limit::signaling_NaN()}, tstorage{int64_t(1)}))));
+
+  EXPECT_THROW(mod(tstorage{double(3)}, tstorage{int64_t(0)}),
+               std::domain_error);
+}
+
+TEST(arithmetic, mod_double_uint64_t) {
+  ASSERT_TRUE(std::holds_alternative<double>(
+      mod(tstorage{double(1)}, tstorage{uint64_t(1)})));
+
+  EXPECT_EQ(std::get<double>(mod(tstorage{double(4.5)}, tstorage{uint64_t(3)})),
+            1.5);
+  EXPECT_EQ(
+      std::get<double>(mod(tstorage{double(-4.5)}, tstorage{uint64_t(3)})),
+      -1.5);
+
+  using limit = std::numeric_limits<double>;
+  EXPECT_TRUE(isnan(std::get<double>(
+      mod(tstorage{-limit::infinity()}, tstorage{uint64_t(1)}))));
+  EXPECT_TRUE(isnan(std::get<double>(
+      mod(tstorage{limit::infinity()}, tstorage{uint64_t(1)}))));
+  EXPECT_TRUE(isnan(std::get<double>(
+      mod(tstorage{limit::quiet_NaN()}, tstorage{uint64_t(1)}))));
+  EXPECT_TRUE(isnan(std::get<double>(
+      mod(tstorage{limit::signaling_NaN()}, tstorage{uint64_t(1)}))));
+
+  EXPECT_THROW(mod(tstorage{double(3)}, tstorage{uint64_t(0)}),
+               std::domain_error);
+}
+
+TEST(arithmetic, mod_double_double) {
+  ASSERT_TRUE(std::holds_alternative<double>(
+      mod(tstorage{double(1)}, tstorage{double(1)})));
+
+  EXPECT_EQ(
+      std::get<double>(mod(tstorage{double(4.25)}, tstorage{double(2.5)})),
+      1.75);
+  EXPECT_EQ(
+      std::get<double>(mod(tstorage{double(4.25)}, tstorage{double(-2.5)})),
+      1.75);
+  EXPECT_EQ(
+      std::get<double>(mod(tstorage{double(-4.25)}, tstorage{double(2.5)})),
+      -1.75);
+  EXPECT_EQ(
+      std::get<double>(mod(tstorage{double(-4.25)}, tstorage{double(-2.5)})),
+      -1.75);
+
+  using limit = std::numeric_limits<double>;
+  EXPECT_TRUE(isnan(std::get<double>(
+      mod(tstorage{-limit::infinity()}, tstorage{double(1)}))));
+  EXPECT_TRUE(isnan(
+      std::get<double>(mod(tstorage{limit::infinity()}, tstorage{double(1)}))));
+  EXPECT_TRUE(isnan(std::get<double>(
+      mod(tstorage{limit::quiet_NaN()}, tstorage{double(1)}))));
+  EXPECT_TRUE(isnan(std::get<double>(
+      mod(tstorage{limit::signaling_NaN()}, tstorage{double(1)}))));
+
+  EXPECT_THROW(mod(tstorage{double(3)}, tstorage{double(0)}),
+               std::domain_error);
+}
+
+} // namespace math
+} // namespace calculator
