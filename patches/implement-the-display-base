Bottom: f0adf615137c5a12f9e966562e89db1300527af8
Top:    4ac6b5c7cda4cf89f1d51b5807df41014b8feb67
Author: Mark de Wever <koraq@xs4all.nl>
Date:   2021-08-07 20:59:42 +0200

Implement the display base.


---

diff --git a/src/modules/calculator/model.cpp b/src/modules/calculator/model.cpp
index 79e7f42..f3b19c5 100644
--- a/src/modules/calculator/model.cpp
+++ b/src/modules/calculator/model.cpp
@@ -16,12 +16,17 @@ export module calculator.model;
 
 export import calculator.value;
 
+import<charconv>;
+import<format>;
 import<string>;
 import<string_view>;
 export import<vector>;
 
 namespace calculator {
 
+/** The supported bases in the calculator. */
+export enum class tbase { binary, octal, decimal, hexadecimal };
+
 /**
  * The model of the calculator.
  *
@@ -46,8 +51,9 @@ public:
 
   [[nodiscard]] bool stack_empty() const noexcept { return stack_.empty(); }
   [[nodiscard]] size_t stack_size() const noexcept { return stack_.size(); }
-  [[nodiscard]] const std::vector<tvalue> &stack() const noexcept {
-    return stack_;
+  [[nodiscard]] const std::vector<std::string> &stack() const noexcept {
+    synchronise_display();
+    return display_;
   }
 
   // *** Modifiers ***
@@ -68,7 +74,11 @@ public:
   // * Stack *
 
   /** Adds the @p value to the back of the stack. */
-  void stack_push(tvalue value) { stack_.emplace_back(std::move(value)); }
+  void stack_push(tvalue value) {
+    stack_.emplace_back(std::move(value));
+    display_.emplace_back();
+    dirty_ = true;
+  }
 
   /**
    * @returns The last element at the back of the stack.
@@ -101,6 +111,10 @@ public:
 
   [[nodiscard]] const std::string &input_get() const noexcept { return input_; }
 
+  // * Base *
+
+  void base_set(tbase base) { base_ = base; }
+
 private:
   /** The execution issues to report to the user. */
   std::string diagnotics_{};
@@ -114,8 +128,29 @@ private:
    */
   std::vector<tvalue> stack_{};
 
+  /**
+   * The shadow stack with values rendered as string.
+   *
+   * The
+   */
+  mutable std::vector<std::string> display_{};
+
+  /** Is the display in sync with the values? */
+  mutable bool dirty_{false};
+
+  void synchronise_display() const;
+
+  [[nodiscard]] std::string format(const tvalue &value) const;
+
   /** The input buffer used to store the current editting session. */
   std::string input_{};
+
+  /**
+   * The base used to display the contents of the stack.
+   *
+   * @note The input is always base 10, unless the user enters a base prefix.
+   */
+  tbase base_{tbase::decimal};
 };
 
 tvalue tmodel::stack_pop() {
@@ -124,7 +159,70 @@ tvalue tmodel::stack_pop() {
 
   tvalue result = stack_.back();
   stack_.pop_back();
+  display_.pop_back();
+  return result;
+}
+
+void tmodel::synchronise_display() const {
+  if (!dirty_)
+    return;
+
+  for (size_t i = 0; i < display_.size(); ++i)
+    if (display_[i].empty())
+      display_[i] = format(stack_[i]);
+
+  dirty_ = false;
+}
+
+[[nodiscard]] std::string tmodel::format(const tvalue &value) const {
+#if defined(__cpp_lib_format)
+  // All formats use the '@r' prefix, this uses the right alignment in FLTK.
+  switch (base_) {
+  case tbase::binary:
+    return std::format("@r{:#b}", value.get());
+  case tbase::octal:
+    return std::format("@r{:#o}", value.get());
+  case tbase::decimal:
+    return std::format("@r{}", value.get());
+  case tbase::hexadecimal:
+    return std::format("@r{:#x}", value.get());
+  }
+  __builtin_unreachable();
+#else
+  // Initialize with right alignment for FLTK.
+  std::string result = "@r";
+
+  switch (base_) {
+  case tbase::binary: {
+    result += "0b";
+    char buffer[64];
+    char *ptr =
+        std::to_chars(std::begin(buffer), std::end(buffer), value.get(), 2).ptr;
+    result.append(std::begin(buffer), ptr);
+  } break;
+  case tbase::octal: {
+    if (value.get() != 0)
+      result += "0";
+    char buffer[22];
+    char *ptr =
+        std::to_chars(std::begin(buffer), std::end(buffer), value.get(), 8).ptr;
+    result.append(std::begin(buffer), ptr);
+  } break;
+  case tbase::decimal:
+    result += std::to_string(value.get());
+    break;
+
+  case tbase::hexadecimal: {
+    result += "0x";
+    char buffer[8];
+    char *ptr =
+        std::to_chars(std::begin(buffer), std::end(buffer), value.get(), 16)
+            .ptr;
+    result.append(std::begin(buffer), ptr);
+  } break;
+  }
   return result;
+#endif
 }
 
 } // namespace calculator
diff --git a/src/modules/calculator/value.cpp b/src/modules/calculator/value.cpp
index 667e40b..a75f989 100644
--- a/src/modules/calculator/value.cpp
+++ b/src/modules/calculator/value.cpp
@@ -40,9 +40,6 @@ public:
   constexpr void set(int64_t value) noexcept { value_ = value; }
   [[nodiscard]] constexpr int64_t get() const noexcept { return value_; }
 
-  /** @returns The formatted output of the value. */
-  [[nodiscard]] std::string format() const { return std::to_string(value_); };
-
 private:
   int64_t value_{0};
 
diff --git a/src/rpn.cpp b/src/rpn.cpp
index a615965..f66d216 100644
--- a/src/rpn.cpp
+++ b/src/rpn.cpp
@@ -95,17 +95,12 @@ void twindow::process_input_event() {
   controller_.append(text);
 }
 
-/** @return The FLTK right-justified formatted output of @p value. */
-static std::string format(const calculator::tvalue &value) {
-  return "@r" + value.format();
-}
-
 void twindow::update_ui() {
   diagnostics_.label(model_.diagnostics_get().c_str());
 
   stack_.clear();
   for (const auto &value : model_.stack())
-    stack_.insert(std::numeric_limits<int>::max(), format(value).c_str());
+    stack_.insert(std::numeric_limits<int>::max(), value.c_str());
   stack_.bottomline(stack_.size());
 
   input_.label(model_.input_get().c_str());
diff --git a/tests/calculator/model.cpp b/tests/calculator/model.cpp
index fa266e6..16fafdb 100644
--- a/tests/calculator/model.cpp
+++ b/tests/calculator/model.cpp
@@ -65,19 +65,60 @@ TEST(model, stack_size) {
   static_assert(noexcept(model.stack_size()));
 }
 
-TEST(model, stack) {
+TEST(model, stack_base_default) {
   {
     const tmodel model;
     static_assert(noexcept(model.stack()));
   }
 
   tmodel model;
-  const std::vector<tvalue> &stack = model.stack();
   model.stack_push(42);
-  EXPECT_EQ(stack, model.stack());
+  model.stack_push(100);
+  EXPECT_EQ(model.stack(), (std::vector<std::string>{{"@r42"}, {"@r100"}}));
 
   (void)model.stack_pop();
-  EXPECT_EQ(stack, model.stack());
+  (void)model.stack_pop();
+  EXPECT_EQ(model.stack(), std::vector<std::string>{});
+}
+
+TEST(model, stack_base_2) {
+  tmodel model;
+  model.base_set(tbase::binary);
+  model.stack_push(42);
+  EXPECT_EQ(model.stack(), std::vector<std::string>{"@r0b101010"});
+
+  (void)model.stack_pop();
+  EXPECT_EQ(model.stack(), std::vector<std::string>{});
+}
+
+TEST(model, stack_base_8) {
+  tmodel model;
+  model.base_set(tbase::octal);
+  model.stack_push(42);
+  EXPECT_EQ(model.stack(), std::vector<std::string>{"@r052"});
+
+  (void)model.stack_pop();
+  EXPECT_EQ(model.stack(), std::vector<std::string>{});
+}
+
+TEST(model, stack_base_10) {
+  tmodel model;
+  model.base_set(tbase::decimal);
+  model.stack_push(42);
+  EXPECT_EQ(model.stack(), std::vector<std::string>{"@r42"});
+
+  (void)model.stack_pop();
+  EXPECT_EQ(model.stack(), std::vector<std::string>{});
+}
+
+TEST(model, stack_base_16) {
+  tmodel model;
+  model.base_set(tbase::hexadecimal);
+  model.stack_push(42);
+  EXPECT_EQ(model.stack(), std::vector<std::string>{"@r0x2a"});
+
+  (void)model.stack_pop();
+  EXPECT_EQ(model.stack(), std::vector<std::string>{});
 }
 
 TEST(model, stack_push) {
diff --git a/tests/calculator/value.cpp b/tests/calculator/value.cpp
index bd03ca4..3056eee 100644
--- a/tests/calculator/value.cpp
+++ b/tests/calculator/value.cpp
@@ -21,14 +21,12 @@ TEST(value, default_constructor) {
   static_assert(noexcept(tvalue{}));
   constexpr tvalue value;
   EXPECT_EQ(value.get(), 0);
-  EXPECT_EQ(value.format(), "0");
 }
 
 TEST(value, converting_constructor) {
   static_assert(noexcept(tvalue{1}));
   constexpr tvalue value = 1;
   EXPECT_EQ(value.get(), 1);
-  EXPECT_EQ(value.format(), "1");
 }
 
 TEST(value, copy_constructor) {
@@ -37,9 +35,7 @@ TEST(value, copy_constructor) {
 
   constexpr tvalue value{v};
   EXPECT_EQ(v.get(), 1);
-  EXPECT_EQ(value.format(), "1");
   EXPECT_EQ(value.get(), 1);
-  EXPECT_EQ(value.format(), "1");
 }
 
 TEST(value, move_constructor) {
@@ -48,7 +44,6 @@ TEST(value, move_constructor) {
 
   constexpr tvalue value{std::move(v)};
   EXPECT_EQ(v.get(), 1);
-  EXPECT_EQ(value.format(), "1");
 }
 
 TEST(value, destructor) { static_assert(noexcept(tvalue{}.~tvalue())); }
@@ -60,15 +55,12 @@ TEST(value, copy_assignment) {
 
   value = v;
   EXPECT_EQ(v.get(), 1);
-  EXPECT_EQ(v.format(), "1");
 
   EXPECT_EQ(value.get(), 1);
-  EXPECT_EQ(value.format(), "1");
 
   // Uses implicit constructor.
   value = 42;
   EXPECT_EQ(value.get(), 42);
-  EXPECT_EQ(value.format(), "42");
 }
 
 TEST(value, move_assignment) {
@@ -78,7 +70,6 @@ TEST(value, move_assignment) {
 
   value = std::move(v);
   EXPECT_EQ(value.get(), 1);
-  EXPECT_EQ(value.format(), "1");
 }
 
 TEST(value, set) {
@@ -86,11 +77,9 @@ TEST(value, set) {
   static_assert(noexcept(value.set(42)));
   value.set(42);
   EXPECT_EQ(value.get(), 42);
-  EXPECT_EQ(value.format(), "42");
 
   value.set(1);
   EXPECT_EQ(value.get(), 1);
-  EXPECT_EQ(value.format(), "1");
 }
 
 TEST(value, get) {
