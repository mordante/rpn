Bottom: a58e3db4295a051bc1e0a7c7798255a9f7b36597
Top:    fab5a69f162c380d6cfcf4afdb4b816ac48e1ed5
Author: Mark de Wever <koraq@xs4all.nl>
Date:   2021-08-07 08:19:50 +0200

Add a calculator model object.

This contains the entire calculator model used in the application.


---

diff --git a/src/modules/calculator/CMakeLists.txt b/src/modules/calculator/CMakeLists.txt
index a221ed8..089f030 100644
--- a/src/modules/calculator/CMakeLists.txt
+++ b/src/modules/calculator/CMakeLists.txt
@@ -1,9 +1,14 @@
 add_library(calculator
+	model.cpp
 	value.cpp
 )
 target_compile_options(calculator
 	PRIVATE
 		${module_compile_options}
 )
+add_module(calculator.model model.cpp)
 add_module(calculator.value value.cpp)
-add_dependencies(calculator calculator.value.pcm)
+add_dependencies(calculator
+	calculator.model.pcm
+	calculator.value.pcm
+)
diff --git a/src/modules/calculator/model.cpp b/src/modules/calculator/model.cpp
new file mode 100644
index 0000000..c799329
--- /dev/null
+++ b/src/modules/calculator/model.cpp
@@ -0,0 +1,130 @@
+/*
+ * Copyright (C) Mark de Wever <koraq@xs4all.nl>
+ * Part of the RPN project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY.
+ *
+ * See the COPYING file for more details.
+ */
+
+export module calculator.model;
+
+export import calculator.value;
+
+import<string>;
+import<string_view>;
+import<vector>;
+
+namespace calculator {
+
+/**
+ * The model of the calculator.
+ *
+ * For now a very basic version of this class.
+ *
+ * The class is non-copyable and non-movable. These operations make little
+ * sense for the model and are most likely logic errors.
+ */
+export class tmodel final {
+public:
+  // *** SMF ***
+
+  tmodel() = default;
+  tmodel(const tmodel &) = delete;
+  tmodel(tmodel &&) = delete;
+  ~tmodel() = default;
+
+  tmodel &operator=(const tmodel &) = delete;
+  tmodel &operator=(tmodel &&) = delete;
+
+  // *** Query ***
+
+  [[nodiscard]] bool stack_empty() const noexcept { return stack_.empty(); }
+  [[nodiscard]] size_t stack_size() const noexcept { return stack_.size(); }
+  [[nodiscard]] const std::vector<tvalue> &stack() const noexcept {
+    return stack_;
+  }
+
+  // *** Modifiers ***
+
+  // * Diagnostics *
+
+  void diagnostics_set(std::string &&diagnotics) {
+    diagnotics_ = std::move(diagnotics);
+  }
+
+  [[nodiscard]] const std::string &diagnostics_get() const noexcept {
+    return diagnotics_;
+  }
+
+  /** Clears the current diagnostics. */
+  void diagnostics_clear() noexcept { diagnotics_.clear(); }
+
+  // * Stack *
+
+  /** Adds the @p value to the back of the stack. */
+  void stack_push(tvalue value) { stack_.emplace_back(std::move(value)); }
+
+  /**
+   * @returns The last element at the back of the stack.
+   * @throws @ref std::out_of_range when the stack is empty.
+   */
+  [[nodiscard]] tvalue stack_pop();
+
+  // * Input *
+
+  /**
+   * Clears the current input.
+   *
+   * TODO Is this function still needed?
+   */
+  void input_clear() noexcept { input_.clear(); }
+
+  /** Returns the clears the input and returns the original value. */
+  [[nodiscard]] std::string input_steal() {
+    std::string result;
+    std::swap(input_, result);
+    return result;
+  }
+
+  /**
+   * Appends the @p data to the @ref input_. @note Since the expected usage
+   * pattern is that the user only append (and maybe later removes) input
+   * there's no setter required.
+   */
+  void input_append(std::string_view data) { input_.append(data); }
+
+  [[nodiscard]] const std::string &input_get() const noexcept { return input_; }
+
+private:
+  /** The execution issues to report to the user. */
+  std::string diagnotics_{};
+
+  /**
+   * The stack with all values of the applications.
+   *
+   * The usage pattern is a LIFO. Since @ref std::vector operates faster on the
+   * the back new elements are added to the back. So the first item is the
+   * oldest item.
+   */
+  std::vector<tvalue> stack_{};
+
+  /** The input buffer used to store the current editting session. */
+  std::string input_{};
+};
+
+tvalue tmodel::stack_pop() {
+  if (stack_.empty())
+    throw std::out_of_range("Stack is empty");
+
+  tvalue result = stack_.back();
+  stack_.pop_back();
+  return result;
+}
+
+} // namespace calculator
diff --git a/src/modules/calculator/value.cpp b/src/modules/calculator/value.cpp
index 0411824..667e40b 100644
--- a/src/modules/calculator/value.cpp
+++ b/src/modules/calculator/value.cpp
@@ -45,6 +45,9 @@ public:
 
 private:
   int64_t value_{0};
+
+  /** Only equality comparable is part of the contract. */
+  friend auto operator<=>(const tvalue &, const tvalue &) = default;
 };
 
 } // namespace calculator
diff --git a/tests/CMakeLists.txt b/tests/CMakeLists.txt
index d1587d5..da0f188 100644
--- a/tests/CMakeLists.txt
+++ b/tests/CMakeLists.txt
@@ -1,4 +1,5 @@
 add_executable(tests
+	calculator/model.cpp
 	calculator/value.cpp
 	math.cpp
 )
diff --git a/tests/calculator/model.cpp b/tests/calculator/model.cpp
new file mode 100644
index 0000000..fa266e6
--- /dev/null
+++ b/tests/calculator/model.cpp
@@ -0,0 +1,208 @@
+/*
+ * Copyright (C) Mark de Wever <koraq@xs4all.nl>
+ * Part of the RPN project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY.
+ *
+ * See the COPYING file for more details.
+ */
+
+import calculator.model;
+
+import<type_traits>;
+
+#include <gtest/gtest.h>
+
+namespace calculator {
+
+// *** SMF ***
+
+TEST(model, default_constructor) {
+  const tmodel model;
+  static_assert(noexcept(tmodel{}));
+  EXPECT_TRUE(model.diagnostics_get().empty());
+  EXPECT_TRUE(model.stack_empty());
+  EXPECT_EQ(model.stack_size(), 0);
+  EXPECT_TRUE(model.input_get().empty());
+}
+
+TEST(model, copy_constructor) {
+  static_assert(!std ::is_copy_constructible_v<tmodel>,
+                "Implement the proper tests.");
+}
+
+TEST(model, move_constructor) {
+  static_assert(!std ::is_move_constructible_v<tmodel>,
+                "Implement the proper tests.");
+}
+
+TEST(model, destructor) { static_assert(noexcept(tmodel{}.~tmodel())); }
+
+TEST(model, copy_assignment) {
+  static_assert(!std ::is_copy_assignable_v<tmodel>,
+                "Implement the proper tests.");
+}
+
+TEST(model, move_assignment) {
+  static_assert(!std ::is_move_assignable_v<tmodel>,
+                "Implement the proper tests.");
+}
+
+// *** Stack operations ***
+
+TEST(model, stack_empty) {
+  const tmodel model;
+  static_assert(noexcept(model.stack_empty()));
+}
+
+TEST(model, stack_size) {
+  const tmodel model;
+  static_assert(noexcept(model.stack_size()));
+}
+
+TEST(model, stack) {
+  {
+    const tmodel model;
+    static_assert(noexcept(model.stack()));
+  }
+
+  tmodel model;
+  const std::vector<tvalue> &stack = model.stack();
+  model.stack_push(42);
+  EXPECT_EQ(stack, model.stack());
+
+  (void)model.stack_pop();
+  EXPECT_EQ(stack, model.stack());
+}
+
+TEST(model, stack_push) {
+  tmodel model;
+
+  model.stack_push(42);
+  EXPECT_TRUE(model.diagnostics_get().empty());
+  EXPECT_FALSE(model.stack_empty());
+  EXPECT_EQ(model.stack_size(), 1);
+  EXPECT_TRUE(model.input_get().empty());
+
+  model.stack_push(42);
+  EXPECT_TRUE(model.diagnostics_get().empty());
+  EXPECT_FALSE(model.stack_empty());
+  EXPECT_EQ(model.stack_size(), 2);
+  EXPECT_TRUE(model.input_get().empty());
+}
+
+TEST(model, stack_pop) {
+  tmodel model;
+  tvalue value;
+
+  model.stack_push(42);
+  model.stack_push(1);
+
+  value = model.stack_pop();
+  EXPECT_EQ(value.get(), 1);
+  EXPECT_TRUE(model.diagnostics_get().empty());
+  EXPECT_FALSE(model.stack_empty());
+  EXPECT_EQ(model.stack_size(), 1);
+  EXPECT_TRUE(model.input_get().empty());
+
+  value = model.stack_pop();
+  EXPECT_EQ(value.get(), 42);
+  EXPECT_TRUE(model.diagnostics_get().empty());
+  EXPECT_TRUE(model.stack_empty());
+  EXPECT_EQ(model.stack_size(), 0);
+  EXPECT_TRUE(model.input_get().empty());
+
+  EXPECT_THROW((void)model.stack_pop(), std::out_of_range);
+}
+
+// *** Diagnostic operations ***
+
+TEST(model, diagnostics_get) {
+  const tmodel model;
+  static_assert(noexcept(model.diagnostics_get()));
+}
+
+TEST(model, diagnostics_set) {
+  tmodel model;
+
+  model.diagnostics_set("abc");
+  EXPECT_EQ(model.diagnostics_get(), "abc");
+  EXPECT_TRUE(model.stack_empty());
+  EXPECT_EQ(model.stack_size(), 0);
+  EXPECT_TRUE(model.input_get().empty());
+
+  model.diagnostics_set("");
+  EXPECT_TRUE(model.diagnostics_get().empty());
+  EXPECT_TRUE(model.stack_empty());
+  EXPECT_TRUE(model.input_get().empty());
+  EXPECT_EQ(model.stack_size(), 0);
+}
+
+TEST(model, diagnostics_clear) {
+  tmodel model;
+  static_assert(noexcept(model.diagnostics_clear()));
+
+  model.diagnostics_set("abc");
+
+  model.diagnostics_clear();
+  EXPECT_TRUE(model.diagnostics_get().empty());
+  EXPECT_TRUE(model.stack_empty());
+  EXPECT_EQ(model.stack_size(), 0);
+  EXPECT_TRUE(model.input_get().empty());
+}
+
+// *** Input operations ***
+
+TEST(model, input_get) {
+  const tmodel model;
+  static_assert(noexcept(model.input_get()));
+}
+
+TEST(model, input_append) {
+  tmodel model;
+
+  model.input_append("abc");
+  EXPECT_TRUE(model.diagnostics_get().empty());
+  EXPECT_TRUE(model.stack_empty());
+  EXPECT_EQ(model.stack_size(), 0);
+  EXPECT_EQ(model.input_get(), "abc");
+
+  model.input_append("def");
+  EXPECT_TRUE(model.diagnostics_get().empty());
+  EXPECT_TRUE(model.stack_empty());
+  EXPECT_EQ(model.stack_size(), 0);
+  EXPECT_EQ(model.input_get(), "abcdef");
+}
+
+TEST(model, input_clear) {
+  tmodel model;
+  static_assert(noexcept(model.input_clear()));
+
+  model.input_append("abc");
+
+  model.input_clear();
+  EXPECT_TRUE(model.diagnostics_get().empty());
+  EXPECT_TRUE(model.stack_empty());
+  EXPECT_EQ(model.stack_size(), 0);
+  EXPECT_TRUE(model.input_get().empty());
+}
+
+TEST(model, input_steal) {
+  tmodel model;
+  model.input_append("abc");
+
+  const std::string input = model.input_steal();
+  EXPECT_EQ(input, "abc");
+
+  EXPECT_TRUE(model.diagnostics_get().empty());
+  EXPECT_TRUE(model.stack_empty());
+  EXPECT_EQ(model.stack_size(), 0);
+  EXPECT_TRUE(model.input_get().empty());
+}
+
+} // namespace calculator
diff --git a/tests/calculator/value.cpp b/tests/calculator/value.cpp
index 9e1d8aa..bd03ca4 100644
--- a/tests/calculator/value.cpp
+++ b/tests/calculator/value.cpp
@@ -18,14 +18,14 @@ import calculator.value;
 
 namespace calculator {
 TEST(value, default_constructor) {
-  EXPECT_TRUE(noexcept(tvalue{}));
+  static_assert(noexcept(tvalue{}));
   constexpr tvalue value;
   EXPECT_EQ(value.get(), 0);
   EXPECT_EQ(value.format(), "0");
 }
 
 TEST(value, converting_constructor) {
-  EXPECT_TRUE(noexcept(tvalue{1}));
+  static_assert(noexcept(tvalue{1}));
   constexpr tvalue value = 1;
   EXPECT_EQ(value.get(), 1);
   EXPECT_EQ(value.format(), "1");
@@ -33,7 +33,7 @@ TEST(value, converting_constructor) {
 
 TEST(value, copy_constructor) {
   constexpr tvalue v = 1;
-  EXPECT_TRUE(noexcept(tvalue{v}));
+  static_assert(noexcept(tvalue{v}));
 
   constexpr tvalue value{v};
   EXPECT_EQ(v.get(), 1);
@@ -44,19 +44,19 @@ TEST(value, copy_constructor) {
 
 TEST(value, move_constructor) {
   constexpr tvalue v = 1;
-  EXPECT_TRUE(noexcept(tvalue{std::move(v)}));
+  static_assert(noexcept(tvalue{std::move(v)}));
 
   constexpr tvalue value{std::move(v)};
   EXPECT_EQ(v.get(), 1);
   EXPECT_EQ(value.format(), "1");
 }
 
-TEST(value, destructor) { EXPECT_TRUE(noexcept(tvalue{}.~tvalue())); }
+TEST(value, destructor) { static_assert(noexcept(tvalue{}.~tvalue())); }
 
 TEST(value, copy_assignment) {
   constexpr tvalue v = 1;
   tvalue value;
-  EXPECT_TRUE(noexcept(value.operator=(v)));
+  static_assert(noexcept(value.operator=(v)));
 
   value = v;
   EXPECT_EQ(v.get(), 1);
@@ -74,7 +74,7 @@ TEST(value, copy_assignment) {
 TEST(value, move_assignment) {
   constexpr tvalue v = 1;
   tvalue value;
-  EXPECT_TRUE(noexcept(value.operator=(std::move(v))));
+  static_assert(noexcept(value.operator=(std::move(v))));
 
   value = std::move(v);
   EXPECT_EQ(value.get(), 1);
@@ -83,7 +83,7 @@ TEST(value, move_assignment) {
 
 TEST(value, set) {
   tvalue value;
-  EXPECT_TRUE(noexcept(value.set(42)));
+  static_assert(noexcept(value.set(42)));
   value.set(42);
   EXPECT_EQ(value.get(), 42);
   EXPECT_EQ(value.format(), "42");
@@ -95,7 +95,11 @@ TEST(value, set) {
 
 TEST(value, get) {
   constexpr tvalue value;
-  EXPECT_TRUE(noexcept(value.get()));
+  static_assert(noexcept(value.get()));
+}
+
+TEST(value, equality_comparible) {
+  static_assert(std::equality_comparable<tvalue>);
 }
 
 } // namespace calculator
