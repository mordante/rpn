Bottom: bbfd1bcc61fef3c71c96e75e3b0a2216c3bb7246
Top:    31401ce44e5b010bc4ef3e71fdfd77c2a7356e99
Author: Mark de Wever <koraq@xs4all.nl>
Date:   2021-08-07 08:19:50 +0200

Add a calculator model object.

This contains the entire calculator model used in the application.


---

diff --git a/src/modules/calculator/CMakeLists.txt b/src/modules/calculator/CMakeLists.txt
index a221ed8..089f030 100644
--- a/src/modules/calculator/CMakeLists.txt
+++ b/src/modules/calculator/CMakeLists.txt
@@ -1,9 +1,14 @@
 add_library(calculator
+	model.cpp
 	value.cpp
 )
 target_compile_options(calculator
 	PRIVATE
 		${module_compile_options}
 )
+add_module(calculator.model model.cpp)
 add_module(calculator.value value.cpp)
-add_dependencies(calculator calculator.value.pcm)
+add_dependencies(calculator
+	calculator.model.pcm
+	calculator.value.pcm
+)
diff --git a/src/modules/calculator/model.cpp b/src/modules/calculator/model.cpp
new file mode 100644
index 0000000..cb0ace1
--- /dev/null
+++ b/src/modules/calculator/model.cpp
@@ -0,0 +1,116 @@
+/*
+ * Copyright (C) Mark de Wever <koraq@xs4all.nl>
+ * Part of the RPN project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY.
+ *
+ * See the COPYING file for more details.
+ */
+
+export module calculator.model;
+
+export import calculator.value;
+
+import<string>;
+import<string_view>;
+import<vector>;
+
+namespace calculator {
+
+/**
+ * The model of the calculator.
+ *
+ * For now a very basic version of this class.
+ *
+ * The class is non-copyable and non-movable. These operations make little
+ * sense for the model and are most likely logic errors.
+ */
+export class tmodel final {
+public:
+  // *** SMF ***
+
+  tmodel() = default;
+  tmodel(const tmodel &) = delete;
+  tmodel(tmodel &&) = delete;
+  ~tmodel() = default;
+
+  tmodel &operator=(const tmodel &) = delete;
+  tmodel &operator=(tmodel &&) = delete;
+
+  // *** Query ***
+
+  [[nodiscard]] bool stack_empty() const noexcept { return stack_.empty(); }
+  [[nodiscard]] size_t stack_size() const noexcept { return stack_.size(); }
+
+  // *** Modifiers ***
+
+  // * Diagnostics *
+
+  void diagnostics_set(std::string &&diagnotics) {
+    diagnotics_ = std::move(diagnotics);
+  }
+
+  [[nodiscard]] const std::string &diagnostics_get() const noexcept {
+    return diagnotics_;
+  }
+
+  /** Clears the current diagnostics. */
+  void diagnostics_clear() noexcept { diagnotics_.clear(); }
+
+  // * Stack *
+
+  /** Adds the @p value to the back of the stack. */
+  void stack_push(tvalue value) { stack_.emplace_back(std::move(value)); }
+
+  /**
+   * @returns The last element at the back of the stack.
+   * @throws @ref std::out_of_range when the stack is empty.
+   */
+  [[nodiscard]] tvalue stack_pop();
+
+  // * Input *
+
+  /** Clears the current input. */
+  void input_clear() noexcept { input_.clear(); }
+
+  /**
+   * Appends the @p data to the @ref input_. @note Since the expected usage
+   * pattern is that the user only append (and maybe later removes) input
+   * there's no setter required.
+   */
+  void input_append(std::string_view data) { input_.append(data); }
+
+  [[nodiscard]] const std::string &input_get() const noexcept { return input_; }
+
+private:
+  /** The execution issues to report to the user. */
+  std::string diagnotics_{};
+
+  /**
+   * The stack with all values of the applications.
+   *
+   * The usage pattern is a LIFO. Since @ref std::vector operates faster on the
+   * the back new elements are added to the back. So the first item is the
+   * oldest item.
+   */
+  std::vector<tvalue> stack_{};
+
+  /** The input buffer used to store the current editting session. */
+  std::string input_{};
+};
+
+tvalue tmodel::stack_pop() {
+  if (stack_.empty())
+    throw std::out_of_range("Stack is empty");
+
+  tvalue result = stack_.back();
+  stack_.pop_back();
+  return result;
+}
+
+} // namespace calculator
diff --git a/tests/CMakeLists.txt b/tests/CMakeLists.txt
index 1be6d9c..24dbb5f 100644
--- a/tests/CMakeLists.txt
+++ b/tests/CMakeLists.txt
@@ -1,4 +1,5 @@
 add_executable(tests
+	calculator/model.cpp
 	calculator/value.cpp
 	math.cpp
 )
diff --git a/tests/calculator/model.cpp b/tests/calculator/model.cpp
new file mode 100644
index 0000000..e41a56d
--- /dev/null
+++ b/tests/calculator/model.cpp
@@ -0,0 +1,171 @@
+/*
+ * Copyright (C) Mark de Wever <koraq@xs4all.nl>
+ * Part of the RPN project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY.
+ *
+ * See the COPYING file for more details.
+ */
+
+import calculator.model;
+
+import<type_traits>;
+
+#include <gtest/gtest.h>
+
+namespace calculator {
+
+TEST(model, default_constructor) {
+  const tmodel model;
+  EXPECT_TRUE(model.diagnostics_get().empty());
+  EXPECT_TRUE(model.stack_empty());
+  EXPECT_EQ(model.stack_size(), 0);
+  EXPECT_TRUE(model.input_get().empty());
+}
+
+TEST(model, copy_constructor) {
+  EXPECT_FALSE(std::is_copy_constructible_v<tmodel>)
+      << "Implement the proper tests.";
+}
+
+TEST(model, move_constructor) {
+  EXPECT_FALSE(std::is_move_constructible_v<tmodel>)
+      << "Implement the proper tests.";
+}
+
+TEST(model, destructor) { EXPECT_TRUE(noexcept(tmodel{}.~tmodel())); }
+
+TEST(model, copy_assignment) {
+  EXPECT_FALSE(std::is_copy_assignable_v<tmodel>)
+      << "Implement the proper tests.";
+}
+
+TEST(model, move_assignment) {
+  EXPECT_FALSE(std::is_move_assignable_v<tmodel>)
+      << "Implement the proper tests.";
+}
+
+TEST(model, stack_empty) {
+  const tmodel model;
+  EXPECT_TRUE(noexcept(model.stack_empty()));
+}
+
+TEST(model, stack_size) {
+  const tmodel model;
+  EXPECT_TRUE(noexcept(model.stack_size()));
+}
+
+TEST(model, stack_push) {
+  tmodel model;
+
+  model.stack_push(42);
+  EXPECT_TRUE(model.diagnostics_get().empty());
+  EXPECT_FALSE(model.stack_empty());
+  EXPECT_EQ(model.stack_size(), 1);
+  EXPECT_TRUE(model.input_get().empty());
+
+  model.stack_push(42);
+  EXPECT_TRUE(model.diagnostics_get().empty());
+  EXPECT_FALSE(model.stack_empty());
+  EXPECT_EQ(model.stack_size(), 2);
+  EXPECT_TRUE(model.input_get().empty());
+}
+
+TEST(model, stack_pop) {
+  tmodel model;
+  tvalue value;
+
+  model.stack_push(42);
+  model.stack_push(1);
+
+  value = model.stack_pop();
+  EXPECT_EQ(value.get(), 1);
+  EXPECT_TRUE(model.diagnostics_get().empty());
+  EXPECT_FALSE(model.stack_empty());
+  EXPECT_EQ(model.stack_size(), 1);
+  EXPECT_TRUE(model.input_get().empty());
+
+  value = model.stack_pop();
+  EXPECT_EQ(value.get(), 42);
+  EXPECT_TRUE(model.diagnostics_get().empty());
+  EXPECT_TRUE(model.stack_empty());
+  EXPECT_EQ(model.stack_size(), 0);
+  EXPECT_TRUE(model.input_get().empty());
+
+  EXPECT_THROW((void)model.stack_pop(), std::out_of_range);
+}
+
+TEST(model, diagnostics_get) {
+  const tmodel model;
+  EXPECT_TRUE(noexcept(model.diagnostics_get()));
+}
+
+TEST(model, diagnostics_set) {
+  tmodel model;
+
+  model.diagnostics_set("abc");
+  EXPECT_EQ(model.diagnostics_get(), "abc");
+  EXPECT_TRUE(model.stack_empty());
+  EXPECT_EQ(model.stack_size(), 0);
+  EXPECT_TRUE(model.input_get().empty());
+
+  model.diagnostics_set("");
+  EXPECT_TRUE(model.diagnostics_get().empty());
+  EXPECT_TRUE(model.stack_empty());
+  EXPECT_TRUE(model.input_get().empty());
+  EXPECT_EQ(model.stack_size(), 0);
+}
+
+TEST(model, diagnostics_clear) {
+  tmodel model;
+  EXPECT_TRUE(noexcept(model.diagnostics_clear()));
+
+  model.diagnostics_set("abc");
+
+  model.diagnostics_clear();
+  EXPECT_TRUE(model.diagnostics_get().empty());
+  EXPECT_TRUE(model.stack_empty());
+  EXPECT_EQ(model.stack_size(), 0);
+  EXPECT_TRUE(model.input_get().empty());
+}
+
+TEST(model, input_get) {
+  const tmodel model;
+  EXPECT_TRUE(noexcept(model.input_get()));
+}
+
+TEST(model, input_append) {
+  tmodel model;
+
+  model.input_append("abc");
+  EXPECT_TRUE(model.diagnostics_get().empty());
+  EXPECT_TRUE(model.stack_empty());
+  EXPECT_EQ(model.stack_size(), 0);
+  EXPECT_EQ(model.input_get(), "abc");
+
+  model.input_append("def");
+  EXPECT_TRUE(model.diagnostics_get().empty());
+  EXPECT_TRUE(model.stack_empty());
+  EXPECT_EQ(model.stack_size(), 0);
+  EXPECT_EQ(model.input_get(), "abcdef");
+}
+
+TEST(model, input_clear) {
+  tmodel model;
+  EXPECT_TRUE(noexcept(model.input_clear()));
+
+  model.input_append("abc");
+
+  model.input_clear();
+  EXPECT_TRUE(model.input_get().empty());
+  EXPECT_TRUE(model.stack_empty());
+  EXPECT_EQ(model.stack_size(), 0);
+  EXPECT_TRUE(model.input_get().empty());
+}
+
+} // namespace calculator
