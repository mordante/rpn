Bottom: ebd12a3c7f7782c2f293dede62fd215fa644327d
Top:    bf0330039ddb7492c9d32da5cfea387f7b606a73
Author: Mark de Wever <koraq@xs4all.nl>
Date:   2021-08-07 11:44:09 +0200

Add a calculator controller object.


---

diff --git a/src/modules/calculator/CMakeLists.txt b/src/modules/calculator/CMakeLists.txt
index 683fd89..e3e7585 100644
--- a/src/modules/calculator/CMakeLists.txt
+++ b/src/modules/calculator/CMakeLists.txt
@@ -1,4 +1,5 @@
 add_library(calculator
+	controller.cpp
 	model.cpp
 	value.cpp
 )
@@ -6,11 +7,19 @@ target_compile_options(calculator
 	PRIVATE
 		${module_compile_options}
 )
+target_link_libraries(calculator
+	PRIVATE
+		math
+)
+add_module(calculator.controller controller.cpp)
 add_module(calculator.model model.cpp)
 add_module(calculator.value value.cpp)
 add_dependencies(calculator.model.pcm
 	calculator.value.pcm
 )
-add_dependencies(calculator
+add_dependencies(calculator.controller.pcm
 	calculator.model.pcm
 )
+add_dependencies(calculator
+	calculator.controller.pcm
+)
diff --git a/src/modules/calculator/controller.cpp b/src/modules/calculator/controller.cpp
new file mode 100644
index 0000000..793ebde
--- /dev/null
+++ b/src/modules/calculator/controller.cpp
@@ -0,0 +1,163 @@
+/*
+ * Copyright (C) Mark de Wever <koraq@xs4all.nl>
+ * Part of the RPN project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY.
+ *
+ * See the COPYING file for more details.
+ */
+
+export module calculator.controller;
+
+import calculator.model;
+import math;
+
+import<charconv>;
+import<format>;
+import<string>;
+import<string_view>;
+
+namespace calculator {
+
+/**
+ * The controller of the calculator.
+ *
+ * For now a very basic version of this class.
+ *
+ * The class is non-copyable and non-movable. These operations make little
+ * sense for the model and are most likely logic errors.
+ */
+export class tcontroller final {
+public:
+  // *** SMF ***
+
+  explicit tcontroller(tmodel &model) noexcept : model_(model) {}
+  tcontroller(const tcontroller &) = delete;
+  tcontroller(tcontroller &&) = delete;
+  ~tcontroller() = default;
+
+  tcontroller &operator=(const tcontroller &) = delete;
+  tcontroller &operator=(tcontroller &&) = delete;
+
+  // *** Operations ***
+
+  /**
+   * Appends data to the input.
+   *
+   * The function doesn't modify the diagnostics.
+   */
+  void append(std::string_view data) noexcept;
+
+  /**
+   * Pushes the current input to the stack.
+   *
+   * Upon success the diagnostics are cleared, else they contain the last error.
+   */
+  void push() noexcept;
+
+  /**
+   * Calculates the sum of two values.
+   *
+   * When the input isn't empty equivalent @c pop() @em op @a input
+   * else equivalent @c pop() @em op @c pop()
+   *
+   * Upon success the diagnostics are cleared, else they contain the last error.
+   */
+  void math_add() noexcept;
+
+private:
+  void push(std::string_view input);
+
+  void duplicate_last_entry();
+  void parse(std::string_view input);
+
+  void diagnostics_set(const std::exception &e);
+  tmodel &model_;
+};
+
+void tcontroller::append(std::string_view data) noexcept {
+  try {
+    model_.input_append(data);
+  } catch (const std::exception &e) {
+    diagnostics_set(e);
+  }
+}
+
+void tcontroller::push() noexcept {
+  try {
+    push(model_.input_steal());
+    model_.diagnostics_clear();
+  } catch (const std::exception &e) {
+    diagnostics_set(e);
+  }
+}
+
+void tcontroller::math_add() noexcept {
+  try {
+    if (const std::string input = model_.input_steal(); !input.empty())
+      push(input);
+
+    const tvalue lhs = model_.stack_pop();
+    const tvalue rhs = model_.stack_pop();
+    model_.stack_push(math::add(lhs.get(), rhs.get()));
+    model_.diagnostics_clear();
+  } catch (const std::exception &e) {
+    diagnostics_set(e);
+  }
+}
+
+void tcontroller::push(std::string_view input) {
+  if (input.empty())
+    duplicate_last_entry();
+  else
+    parse(input);
+}
+
+void tcontroller::duplicate_last_entry() {
+  tvalue value = model_.stack_pop();
+  model_.stack_push(value);
+  model_.stack_push(value);
+}
+
+static void validate(std::errc ec) {
+  if (ec == std::errc())
+    return;
+
+  switch (ec) {
+  case std::errc::invalid_argument:
+    throw std::domain_error("Invalid numeric value");
+
+  case std::errc::result_out_of_range:
+    throw std::out_of_range("Value outside of the representable range");
+
+  default:
+    // This happens when the implementation behaves outside the specifications.
+    throw std::domain_error("Unexpected error");
+  }
+}
+
+void tcontroller::parse(std::string_view input) {
+  int64_t value;
+  std::from_chars_result result =
+      std::from_chars(input.begin(), input.end(), value);
+
+  validate(result.ec);
+  if (result.ptr != input.end())
+    throw std::domain_error("Invalid numeric value");
+
+  model_.stack_push(value);
+}
+
+void tcontroller::diagnostics_set(const std::exception &e) {
+#if defined(__cpp_lib_format)
+  model_.diagnostics_set(std::format("[ERR]{:>80.79}", e.what()));
+#else
+  model_.diagnostics_set(e.what());
+#endif
+}
+} // namespace calculator
diff --git a/tests/CMakeLists.txt b/tests/CMakeLists.txt
index da0f188..709a6d9 100644
--- a/tests/CMakeLists.txt
+++ b/tests/CMakeLists.txt
@@ -1,4 +1,5 @@
 add_executable(tests
+	calculator/controller.cpp
 	calculator/model.cpp
 	calculator/value.cpp
 	math.cpp
diff --git a/tests/calculator/controller.cpp b/tests/calculator/controller.cpp
new file mode 100644
index 0000000..adc7bdb
--- /dev/null
+++ b/tests/calculator/controller.cpp
@@ -0,0 +1,293 @@
+/*
+ * Copyright (C) Mark de Wever <koraq@xs4all.nl>
+ * Part of the RPN project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY.
+ *
+ * See the COPYING file for more details.
+ */
+
+import calculator.controller;
+
+import calculator.model;
+
+#include <gtest/gtest.h>
+
+namespace calculator {
+
+// *** SMF ***
+
+TEST(controller, constructor) {
+  tmodel model;
+  const tcontroller controller{model};
+  static_assert(noexcept(tcontroller{model}));
+}
+
+TEST(controller, copy_constructor) {
+  static_assert(!std::is_copy_constructible_v<tcontroller>,
+                "Implement the proper tests.");
+}
+
+TEST(controller, move_constructor) {
+  static_assert(!std::is_move_constructible_v<tcontroller>,
+                "Implement the proper tests.");
+}
+
+TEST(controller, destructor) {
+  tmodel model;
+  static_assert(noexcept(tcontroller{model}.~tcontroller()));
+}
+
+TEST(controller, copy_assignment) {
+  static_assert(!std::is_copy_assignable_v<tcontroller>,
+                "Implement the proper tests.");
+}
+
+TEST(controller, move_assignment) {
+  static_assert(!std::is_move_assignable_v<tcontroller>,
+                "Implement the proper tests.");
+}
+
+// *** append ***
+
+TEST(controller, append) {
+  tmodel model;
+  tcontroller controller{model};
+  static_assert(noexcept(controller.append(std::string_view())));
+
+  controller.append("abc");
+  EXPECT_TRUE(model.diagnostics_get().empty());
+  EXPECT_TRUE(model.stack_empty());
+  EXPECT_EQ(model.input_get(), "abc");
+
+  controller.append("");
+  EXPECT_TRUE(model.diagnostics_get().empty());
+  EXPECT_TRUE(model.stack_empty());
+  EXPECT_EQ(model.input_get(), "abc");
+
+  controller.append("def");
+  EXPECT_TRUE(model.diagnostics_get().empty());
+  EXPECT_TRUE(model.stack_empty());
+  EXPECT_EQ(model.input_get(), "abcdef");
+}
+
+TEST(controller, append_diagnostics_unchanged) {
+  tmodel model;
+  tcontroller controller{model};
+  model.diagnostics_set("Unchanged");
+
+  controller.append("abc");
+  EXPECT_EQ(model.diagnostics_get(), "Unchanged");
+  EXPECT_TRUE(model.stack_empty());
+  EXPECT_EQ(model.input_get(), "abc");
+}
+
+// *** push ***
+
+TEST(controller, push) {
+  tmodel model;
+  tcontroller controller{model};
+  static_assert(noexcept(controller.push()));
+}
+
+static std::string format_error(const char *message) {
+#if defined(__cpp_lib_format)
+  return std::format("[ERR]{:>80.79}", message);
+#else
+  return message;
+#endif
+}
+
+TEST(controller, push_duplicate_empty_stack) {
+  tmodel model;
+  tcontroller controller{model};
+
+  controller.push();
+  EXPECT_EQ(model.diagnostics_get(), format_error("Stack is empty"));
+  EXPECT_TRUE(model.stack_empty());
+  EXPECT_TRUE(model.input_get().empty());
+}
+
+TEST(controller, push_duplicate_non_empty_stack) {
+  tmodel model;
+  tcontroller controller{model};
+  model.stack_push(42);
+
+  controller.push();
+  EXPECT_TRUE(model.diagnostics_get().empty());
+  EXPECT_EQ(model.stack_size(), 2);
+  EXPECT_EQ(model.stack_pop().get(), 42);
+  EXPECT_EQ(model.stack_pop().get(), 42);
+  EXPECT_TRUE(model.input_get().empty());
+}
+
+TEST(controller, push_value_0) {
+  tmodel model;
+  tcontroller controller{model};
+  model.input_append("0");
+
+  controller.push();
+  EXPECT_TRUE(model.diagnostics_get().empty());
+  EXPECT_EQ(model.stack_size(), 1);
+  EXPECT_EQ(model.stack_pop().get(), 0);
+  EXPECT_TRUE(model.input_get().empty());
+}
+
+TEST(controller, push_value_min) {
+  tmodel model;
+  tcontroller controller{model};
+  const int64_t minimum = -9223372036854775807ll - 1;
+  static_assert(std::numeric_limits<decltype(model.stack_pop().get())>::min() ==
+                    minimum,
+                "Update the test below");
+
+  model.input_append("-9223372036854775808");
+  controller.push();
+  EXPECT_TRUE(model.diagnostics_get().empty());
+  EXPECT_EQ(model.stack_size(), 1);
+  EXPECT_EQ(model.stack_pop().get(), minimum);
+  EXPECT_TRUE(model.input_get().empty());
+
+  model.input_append("-9223372036854775809");
+  controller.push();
+  EXPECT_EQ(model.diagnostics_get(),
+            format_error("Value outside of the representable range"));
+  EXPECT_TRUE(model.stack_empty());
+  EXPECT_TRUE(model.input_get().empty());
+}
+
+TEST(controller, push_value_max) {
+  tmodel model;
+  tcontroller controller{model};
+  const int64_t maximum = 9223372036854775807ll;
+  static_assert(std::numeric_limits<decltype(model.stack_pop().get())>::max() ==
+                    maximum,
+                "Update the test below");
+
+  model.input_append("9223372036854775807");
+  controller.push();
+  EXPECT_TRUE(model.diagnostics_get().empty());
+  EXPECT_EQ(model.stack_size(), 1);
+  EXPECT_EQ(model.stack_pop().get(), maximum);
+  EXPECT_TRUE(model.input_get().empty());
+
+  model.input_append("9223372036854775808");
+  controller.push();
+  EXPECT_EQ(model.diagnostics_get(),
+            format_error("Value outside of the representable range"));
+  EXPECT_TRUE(model.stack_empty());
+  EXPECT_TRUE(model.input_get().empty());
+}
+
+TEST(controller, push_invalid_input) {
+  tmodel model;
+  tcontroller controller{model};
+
+  model.input_append("a");
+  controller.push();
+  EXPECT_EQ(model.diagnostics_get(), format_error("Invalid numeric value"));
+  EXPECT_TRUE(model.stack_empty());
+  EXPECT_TRUE(model.input_get().empty());
+}
+
+TEST(controller, push_invalid_input_after_valid_value) {
+  tmodel model;
+  tcontroller controller{model};
+
+  model.input_append("0a");
+  controller.push();
+  EXPECT_EQ(model.diagnostics_get(), format_error("Invalid numeric value"));
+  EXPECT_TRUE(model.stack_empty());
+  EXPECT_TRUE(model.input_get().empty());
+}
+
+TEST(controller, push_diagnostics_cleared) {
+  tmodel model;
+  tcontroller controller{model};
+  model.diagnostics_set("Cleared");
+  model.input_append("42");
+
+  controller.push();
+  EXPECT_TRUE(model.diagnostics_get().empty());
+  EXPECT_EQ(model.stack_size(), 1);
+  EXPECT_EQ(model.stack_pop().get(), 42);
+  EXPECT_TRUE(model.input_get().empty());
+}
+
+// *** math_add ***
+
+TEST(controller, math_add_too_few_elements) {
+  tmodel model;
+  tcontroller controller{model};
+
+  controller.math_add();
+  EXPECT_EQ(model.diagnostics_get(), format_error("Stack is empty"));
+  EXPECT_TRUE(model.stack_empty());
+  EXPECT_TRUE(model.input_get().empty());
+
+  model.stack_push(42);
+  controller.math_add();
+  EXPECT_EQ(model.diagnostics_get(), format_error("Stack is empty"));
+  EXPECT_TRUE(model.stack_empty());
+  EXPECT_TRUE(model.input_get().empty());
+}
+
+TEST(controller, math_add_stack_input) {
+  tmodel model;
+  tcontroller controller{model};
+  model.stack_push(42);
+  model.input_append("42");
+
+  controller.math_add();
+  EXPECT_TRUE(model.diagnostics_get().empty());
+  EXPECT_EQ(model.stack_size(), 1);
+  EXPECT_EQ(model.stack_pop().get(), 84);
+  EXPECT_TRUE(model.input_get().empty());
+}
+
+TEST(controller, math_add_stack_stack) {
+  tmodel model;
+  tcontroller controller{model};
+  model.stack_push(42);
+  model.stack_push(42);
+
+  controller.math_add();
+  EXPECT_TRUE(model.diagnostics_get().empty());
+  EXPECT_EQ(model.stack_size(), 1);
+  EXPECT_EQ(model.stack_pop().get(), 84);
+  EXPECT_TRUE(model.input_get().empty());
+}
+
+TEST(controller, math_add_diagnostics_cleared) {
+  tmodel model;
+  tcontroller controller{model};
+  model.diagnostics_set("Cleared");
+  model.stack_push(42);
+  model.stack_push(42);
+
+  controller.math_add();
+  EXPECT_TRUE(model.diagnostics_get().empty());
+  EXPECT_EQ(model.stack_size(), 1);
+  EXPECT_EQ(model.stack_pop().get(), 84);
+  EXPECT_TRUE(model.input_get().empty());
+}
+
+TEST(controller, math_add_input_invalid) {
+  tmodel model;
+  tcontroller controller{model};
+  model.stack_push(42);
+  model.input_append("abc");
+
+  controller.math_add();
+  EXPECT_EQ(model.diagnostics_get(), "Invalid numeric value");
+  EXPECT_EQ(model.stack_size(), 1);
+  EXPECT_EQ(model.stack_pop().get(), 42);
+  EXPECT_TRUE(model.input_get().empty());
+}
+
+} // namespace calculator
